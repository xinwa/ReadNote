Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执 行字节码，最终转化为汇编指令在 CPU 上执行，Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。本章我们将深入底层一起探索下 Java 并发机制的底层实现 原理。

#### Volatile

#### 可见性：可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

CPU 执行指令，不直接和内存进行交互，而是把内存中的数据读到到内部的高速缓存当中，由 Volatile 修饰的共享资源时，在进行写操作时，会把更新后的内部缓存的值写回到主内存当中，并且使得其他处理器当中的缓存无效

#### Synchornized

Java 中的每一个对象都可以作为锁。 具体表现为以下 3 种形式。

*  对于普通同步方法，锁是当前实例对象。
* 对于静态同步方法，锁是当前类的 Class 对象。
*  对于同步方法块，锁是 Synchonized 括号里配置的对象。

##### 实现细节

代码块同步是使用 monitorenter 和 monitorexit 指令实现的

monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处，JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配 对。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状 态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。

