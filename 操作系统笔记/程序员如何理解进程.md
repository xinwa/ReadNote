在执行程序时，操纵系统会把可执行文件中的代码段和数据段整体拷贝到内存中。开辟栈区为用户程序进行动态分配内存。之后操纵系统开始把 CPU 的程序计数器寄存器设置为代码段中第一条指令的内存地址。

<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211128193318959.png" alt="image-20211128193318959" style="zoom:25%;" />

#### 进程是如何被创建出来的

进程都是由操纵系统创建出来的，但是操纵系统把创建进程作为一项服务提供给了用户程序。

每个进程在系统中都有自己唯一的 id，通常是一个正整数，用来识别进程，这个 id 被称为进程描述符。

Unix 中创建进程的进程被称为父进程，被创建的进程被称为子进程。

#### fork 函数



<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211128194931808.png" alt="image-20211128194931808" style="zoom:25%;" />

fork 创建的子进程的内存其实是父进程的一个拷贝，内容一样但二者位于完全不同的地址空间

#### 进程是如何运行的

##### 进程的三种状态

* 运行：进程处于运行状态
* 就绪：等待被运行的进程状态
* 堵塞：当进程进行 I / O 操纵而数据尚不可用时，进程不得不等待，此时的进程就处于堵塞状态

##### 进程调度的一个例子

当进程进行 I/O操纵时进行系统调用，CPU 开始从用户模式切换到内核模式，系统调用 handler 开始处理，该 handler 发现数据尚未到来，此时操纵系统中的进程调度器开始运行，将 CPU 分配给其他进程。CPU 从内核模式切换回用户模式，其他进程开始运行。

其他进程运行一会后，网络数据终于到来，这时网卡产生中断，CPU 接收到中断之后再一次从用户模式切换到内核模式，开始运行网卡中断处理 handler，将网卡中接收到的数据 copy 到操纵系统内存，之后 copy 到进程中，此时进程调度器发现被堵塞的进程重新具备了运行条件，因为被堵塞的进程可以继续运行，故将堵塞进程的状态改为就绪状态。

##### CPU 从运行到就绪

由于定时器会按照一定的频率产生中断，假设一段时间后定时产生中断，CPU 接收到中断后开始从用户模式转换为内核模式，跳转到操纵系统中执行定时器中断 handler，最终该 handler 会调用到操纵系统的调度器，调度器选择将运行中的进程状态改为就绪状态。

<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211128201819648.png" alt="image-20211128201819648" style="zoom:25%;" />

#### 进程是如何终止的

##### 进程退出的几种情况

* 正常退出
* 错误退出
* 被操纵系统终止
* 被其它进程终止

程序运行起来的样子就是进程。进程内存包含了栈区、堆区、数据段、代码段

#### 进程控制块

进程控制块（Process Control Blocks）简称 PCB。操纵系统使用 PCB 来记录内存中运行的各个进程。

其中包括进程的运行状态，使用的内存空间，打开了哪些文件，创建了哪些子进程，创建该进程的父进程以及调度信息。

#### 进程的上下文

进程切换运行时，需要把之前暂停的进程信息进行恢复，这些信息被称为进程的上下文。

#### 进程切换

操纵系统想要进行进程切换就必须暂停当前进程的运行并恢复某个之前被暂停的进程。从进程的上下文的角度来看，进程切换其实是保存即将被暂停的进程上下文信息，恢复之前被暂停进程的上下文信息，进程切换的本质其实就是上下文信息的保存以及恢复。

进程切换时会将即将被切的进程信息保存在该进程的 PCB 中，读取需要恢复进程的 PCB 信息，更新程序计数器的值，进行进程切换

<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211129150844600.png" alt="image-20211129150844600" style="zoom:25%;" />

