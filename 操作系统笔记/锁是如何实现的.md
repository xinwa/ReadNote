访问共享资源的这段代码被称为临界区，我们希望临界区中的这段代码可以被原子性的额执行，也就是这段代码要么一次性被执行完毕，要么不执行，不存执行到一半的中间状态。



<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211201205847181.png" alt="image-20211201205847181" style="zoom:25%;" />

#### 回旋锁

使用 while 循环不断检测锁的状态直到锁的状态可用为止，另外线程在等待锁可用的过程中是一直在运行的，不会被堵塞起来。

#### 回旋锁的缺点

<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211201213617020.png" alt="image-20211201213617020" style="zoom:25%;" />

#### 不做无用功：操纵系统来帮忙

当线程试图获取锁而锁不可用时，我们只需要将当前线程置于堵塞态暂停运行就可以了，这样当一把锁被某个线程占用后，调度器再也不会去调度另一个同样试图获取该锁的线程了，因为拿不到锁的线程都处于堵塞态，调度器只会从就绪队列中选择一个线程来执行。

如果当前锁不可用时则直接放弃 CPU 并进入堵塞状态，同时将当前线程放到该锁的等待队列中，使用完锁后如果锁的等待队列中有排队等待的线程，则选择一个线程并将其唤醒，这里所谓的额唤醒就是将其从堵塞态置为就绪态。这样调度器重新调度后该线程后就可以使用锁了。

<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211201214520437.png" alt="image-20211201214520437" style="zoom:25%;" />

#### 线程同步

一类线程必须要等待另一类线程完成某种操作才可以继续运行，这就是线程同步

#### 条件变量

条件变量其实就是一个等待队列，当线程依赖的某些执行条件不满足要求时，这些线程主动堵塞放弃cpu并进入条件变量的等待队列中等待。其他线程在改变了执行条件后则唤醒在条件变量中等待的堵塞队列，被堵塞线程继续运行。

volatitle 修饰的变量会让 CPU 老老实实的从内存中读取数据，不要试图走进路而去读取寄存器中的数据。

条件变量其实就是一种通知机制，等待的条件不成立就调用 wait来堵塞放入队列当中以免浪费 CPU 时间，当其他线程改变了条件后使用 signal() 来唤醒堵塞线程

如何等待子线程运行完成

答：条件变量 + 线程是否运行完成的标志 done + 锁 来实现线程同步 

<img src="/Users/xinwa/Library/Application Support/typora-user-images/image-20211202003240631.png" alt="image-20211202003240631" style="zoom:25%;" />

