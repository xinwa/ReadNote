##### 基础关键字

extern : 

define: 预处理指令用于创建符号常量。该符号常量通常称为**宏**

```
#define macro-name replacement-text 
```

const：声明指定类型的常量

unsigned: 无符号的

##### 指针：是一个变量，其值变量的地址

类成员函数：可以定义在类的内部，或者单独使用范围解析运算符 「：：」来定义，在类定义中定义的成员函数把函数声明为内联的

Double Box::geetVolume(void) {

​	return length * breadth * height;

}

构造函数：类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

Line::Line(void) {    cout << "Object is being created" << endl; } 

静态方法：<类名>::<静态函数名>

##### 模版：template 

template <typename type> ret-type func-name(parameter list) {   // 函数的主体 }

##### 「：」冒号用法

* 类名后面的冒号表示继承
* public 和 private 后面的冒号，表示后面定义的所有成员都是公有或者私有的
* 构造函数后面的冒号起分割作用
* 表示该变量占几个 bit 空间



##### 「：：」双冒号

* 类外定义函数时使用
* 引用成员函数或者变量

##### c++11 条款21：尽量使用std::make_unique和std::make_shared而不直接使用new

正如你看到的，make_unique完美传递了参数给对象的构造函数，从一个原始指针构造出一个std::unique_ptr，返回创建的std::unique_ptr。这个形式的函数不支持数组和定制删除器（见条款18），但它证明了一点点的努力就可以根据需要创建一个make_unique。要记住的是不要把你的版本放到std命名空间里，因为你不想当升级到c++14后会和库提供的标准实现冲突吧。

##### 命名空间：

命名空间的定义使用关键字 **namespace**，后跟命名空间的名称，

namespace namespace_name {   // 代码声明 }

为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称

name::code;



